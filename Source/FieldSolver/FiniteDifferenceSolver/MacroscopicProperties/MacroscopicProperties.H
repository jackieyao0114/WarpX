#ifndef WARPX_MACROSCOPICPROPERTIES_H_
#define WARPX_MACROSCOPICPROPERTIES_H_


#include <AMReX_REAL.H>
#include <AMReX_Array4.H>
#include <AMReX_Gpu.H>

#include <AMReX_MultiFab.H>
#include <algorithm>
#include <array>

#include "Parser/WarpXParser.H"
#include "Parser/WarpXParserWrapper.H"
#include "Utils/WarpXConst.H"

/**
 * \brief This class contains the macroscopic parameters of the medium needed to
 * evaluate macroscopic Maxwell equation.
 */
class
MacroscopicProperties
{
public:
     MacroscopicProperties (); // constructor
     /** \brief Read user-defined macroscopic properties. Called in constructor. */
     void ReadParameters ();
     /** Initialize multifabs storing macroscopic multifabs */
     void InitData ();

//     /** return Real, sigma (conductivity) of the medium. */
//     amrex::Real sigma () const noexcept {return m_sigma;}
//     /** return Real, epsilon (permittivity) of the medium. */
//     amrex::Real epsilon () const noexcept {return m_epsilon;}
//     /** return Real, mu (permeability) of the medium. */
//     amrex::Real mu () const noexcept {return m_mu;}
     /** */
     amrex::MultiFab& getsigma_mf  () {return (*m_sigma_mf);}
     amrex::MultiFab& getepsilon_mf  () {return (*m_eps_mf);}
     amrex::MultiFab& getmu_mf  () {return (*m_mu_mf);}
     amrex::MultiFab& getmag_Ms_mf () {return (*m_mag_Ms_mf);}
     amrex::MultiFab& getmag_alpha_mf () {return (*m_mag_alpha_mf);}
     amrex::MultiFab& getmag_gamma_mf () {return (*m_mag_gamma_mf);}

     void InitializeMacroMultiFabUsingParser (amrex::MultiFab *macro_mf,
                                  ParserWrapper<3> *macro_parser, int lev);

     // interpolate the magnetic properties to B locations
     // magnetic properties are cell nodal
     // B locations are face centered
     AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
     static amrex::Real macro_avg_to_face (int i, int j, int k, amrex::IntVect iv, amrex::Array4<amrex::Real> const& macro_mag_prop){
         using namespace amrex;
         return ( 0.125_rt * ( macro_mag_prop(i        ,j        ,k        )
                             + macro_mag_prop(i-iv[0]+1,j        ,k        )
                             + macro_mag_prop(i        ,j-iv[1]+1,k        )
                             + macro_mag_prop(i        ,j        ,k-iv[2]+1)
                             + macro_mag_prop(i        ,j-iv[1]+1,k-iv[2]+1)
                             + macro_mag_prop(i-iv[0]+1,j        ,k-iv[2]+1)
                             + macro_mag_prop(i-iv[0]+1,j-iv[1]+1,k        )
                             + macro_mag_prop(i-iv[0]+1,j-iv[1]+1,k-iv[2]+1)
         ));
     };
     /*  Hy (0,1,0) components (in) to Hx face (1,0,0) (out)
         Hz (0,0,1) components to Hx face (1,0,0)
         Real Hy_xtemp = 0.25*(Hy(i,j,k)+Hy(i,j+1,k)+Hy(i-1,j,k)+Hy(i-1,j+1,k));
         Real Hz_xtemp = 0.25*(Hz(i,j,k)+Hz(i-1,j,k)+Hz(i,j,k+1)+Hz(i-1,j,k+1));

         Hx (1,0,0) components to Hy face (0,1,0)
         Hz (0,0,1) components to Hy face (0,1,0)
         Real Hx_ytemp = 0.25*(Hx(i,j,k)+Hx(i+1,j,k)+Hx(i,j-1,k)+Hx(i+1,j-1,k));
         Real Hz_ytemp = 0.25*(Hz(i,j,k)+Hz(i,j,k+1)+Hz(i,j-1,k)+Hz(i,j-1,k+1));

         Hx (1,0,0) components to Hz face (0,0,1)
         Hy (0,1,0) components to Hz face (0,0,1)

         Real Hx_ztemp = 0.25*(Hx(i,j,k)+Hx(i+1,j,k)+Hx(i+1,j,k-1)+Hx(i,j,k-1));
         Real Hy_ztemp = 0.25*(Hy(i,j,k)+Hy(i,j,k-1)+Hy(i,j+1,k)+Hy(i,j+1,k-1));

         i,j,k are the spatial indices, n is the component index
         iv_in is the input field index type, iv_out is the target index type
     */

     AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
     static amrex::Real face_avg_to_face (int i, int j, int k, int n,
                                           amrex::IntVect iv_in, amrex::IntVect iv_out,
                                           amrex::Array4<amrex::Real> const& Fieldcomp) {
         using namespace amrex;
         return ( 0.125_rt * ( Fieldcomp(i                   , j                   , k                   , n)
                             + Fieldcomp(i+iv_in[0]-iv_out[0], j                   , k                   , n)
                             + Fieldcomp(i                   , j+iv_in[1]-iv_out[1], k                   , n)
                             + Fieldcomp(i                   , j                   , k+iv_in[1]-iv_out[1], n)
                             + Fieldcomp(i+iv_in[0]-iv_out[0], j+iv_in[1]-iv_out[1], k                   , n)
                             + Fieldcomp(i+iv_in[0]-iv_out[0], j                   , k+iv_in[1]-iv_out[1], n)
                             + Fieldcomp(i                   , j+iv_in[1]-iv_out[1], k+iv_in[1]-iv_out[1], n)
                             + Fieldcomp(i+iv_in[0]-iv_out[0], j+iv_in[1]-iv_out[1], k+iv_in[1]-iv_out[1], n)
                             ));
     };

     /**
     calculate local H_maxwell
     note Bcomp always has n=0 because it is a 3d matrix
     while Mcomp has n=0,1,2, indicating x,y,z components
     **/
     AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
     static amrex::Real getH_Maxwell (int i, int j, int k, int n,
                                   amrex::IntVect iv_in, amrex::IntVect iv_out,
                                   amrex::Array4<amrex::Real> const& Bcomp, amrex::Array4<amrex::Real> const& Mcomp) {
         using namespace amrex;
         amrex::Real H_Maxwell = face_avg_to_face(i, j, k, 0, iv_in, iv_out, Bcomp)/PhysConst::mu0
                                 - Mcomp(i, j, k, n); //magnetic constitutive relation
         return H_Maxwell;
     };

private:
     /** Conductivity, sigma, of the medium */
     amrex::Real m_sigma;
     /** Permittivity, epsilon, of the medium */
     amrex::Real m_epsilon;
     /** Permeability, mu, of the medium */
     amrex::Real m_mu;
     /** Saturation magnetization, only applies for magnetic materials */
     amrex::Real m_mag_Ms;
     /** Gilbert damping, only applies for magnetic materials */
     amrex::Real m_mag_alpha;
     /** gyromagnetic ratio, only applies for magnetic materials */
     amrex::Real m_mag_gamma;
     /** Multifab for m_sigma */
     std::unique_ptr<amrex::MultiFab> m_sigma_mf;
     /** Multifab for m_epsilon */
     std::unique_ptr<amrex::MultiFab> m_eps_mf;
     /** Multifab for m_mu */
     std::unique_ptr<amrex::MultiFab> m_mu_mf;
     /** Multifac for m_mag_Ms */
     std::unique_ptr<amrex::MultiFab> m_mag_Ms_mf;
     /** Multifac for m_mag_alpha */
     std::unique_ptr<amrex::MultiFab> m_mag_alpha_mf;
     /** Multifac for m_mag_gamma */
     std::unique_ptr<amrex::MultiFab> m_mag_gamma_mf;

     std::string m_sigma_s;
     std::string m_epsilon_s;
     std::string m_mu_s;
     std::string m_mag_Ms_s;
     std::string m_mag_alpha_s;
     std::string m_mag_gamma_s;

     /** string for storing parser function */
     std::string m_str_sigma_function;
     std::string m_str_epsilon_function;
     std::string m_str_mu_function;
     std::string m_str_mag_Ms_function;
     std::string m_str_mag_alpha_function;
     std::string m_str_mag_gamma_function;
     /** Parser Wrappers */
     // The ParserWrapper struct is constructed to safely use the GpuParser class
     // that can essentially be though of as a raw pointer. The GpuParser does
     // not have an explicit destructor and the AddPlasma subroutines handle the GpuParser
     // in a safe way. The ParserWrapper struct is used to avoid memory leak
     // in the EB parser functions.
     std::unique_ptr<ParserWrapper<3> > m_sigma_parser;
     std::unique_ptr<ParserWrapper<3> > m_epsilon_parser;
     std::unique_ptr<ParserWrapper<3> > m_mu_parser;
     std::unique_ptr<ParserWrapper<3> > m_mag_Ms_parser;
     std::unique_ptr<ParserWrapper<3> > m_mag_alpha_parser;
     std::unique_ptr<ParserWrapper<3> > m_mag_gamma_parser;
};

struct LaxWendroffAlgo {

     // iv(1,0,0) for cell-centered macroparameters to Ex edge
     // iv(0,1,0) for cell-centered macroparameters to Ey edge
     // iv(0,0,1) for cell-centered macroparameters to Ez edge
     // iv(0,1,1) for nodal macroparameters to Ex edge
     // iv(1,0,1) for nodal macroparameters to Ey edge
     // iv(1,1,0) for nodal macroparameters to Ez edge
     AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
     static amrex::Real macro_avg_to_edge (int i, int j, int k, amrex::IntVect iv,
                                           amrex::Array4<amrex::Real> const& macro_prop) {
         using namespace amrex;
         return ( 0.125_rt * ( macro_prop(i,         j,         k        )
                             + macro_prop(i+iv[0]-1, j,         k        )
                             + macro_prop(i,         j+iv[1]-1, k        )
                             + macro_prop(i,         j,         k+iv[2]-1)
                             + macro_prop(i+iv[0]-1, j+iv[1]-1, k        )
                             + macro_prop(i+iv[0]-1, j        , k+iv[2]-1)
                             + macro_prop(i,         j+iv[1]-1, k+iv[2]-1)
                             + macro_prop(i+iv[0]-1, j+iv[1]-1, k+iv[2]-1) ) );
     }

     /** */
     AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
     static amrex::Real alpha (amrex::Array4<amrex::Real> const& sigma,
                               amrex::Array4<amrex::Real> const& epsilon,
                               amrex::Real dt, int i, int j, int k,
                               amrex::IntVect iv_cc) {
         using namespace amrex;
         amrex::Real fac1 = 0.5_rt * macro_avg_to_edge(i, j, k, iv_cc, sigma) * dt
                                   / macro_avg_to_edge(i, j, k, iv_cc, epsilon);
         amrex::Real alpha = (1._rt - fac1)/(1._rt + fac1);
         return alpha;
     };

     AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
     static amrex::Real beta (amrex::Array4<amrex::Real> const& sigma,
                              amrex::Array4<amrex::Real> const& epsilon,
                              amrex::Real dt, int i, int j, int k,
                              amrex::IntVect iv_cc) {
         using namespace amrex;
         amrex::Real fac1 = 0.5_rt * macro_avg_to_edge(i, j, k, iv_cc, sigma) * dt
                                   / macro_avg_to_edge(i, j, k, iv_cc, epsilon);
         amrex::Real beta = dt / ( macro_avg_to_edge(i, j, k, iv_cc, epsilon) * (1._rt + fac1) );
         return beta;
     };
};

struct BackwardEulerAlgo {

     // iv(1,0,0) for cell-centered macroparameters to Ex edge
     // iv(0,1,0) for cell-centered macroparameters to Ey edge
     // iv(0,0,1) for cell-centered macroparameters to Ez edge
     // iv(2,1,1) for nodal macroparameters to Ex edge
     // iv(1,2,1) for nodal macroparameters to Ey edge
     // iv(1,1,2) for nodal macroparameters to Ez edge
     AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
     static amrex::Real macro_avg_to_edge (int i, int j, int k, amrex::IntVect iv,
                                           amrex::Array4<amrex::Real> const& macro_prop) {
         using namespace amrex;
         return ( 0.125_rt * ( macro_prop(i,         j,         k        )
                             + macro_prop(i+iv[0]-1, j,         k        )
                             + macro_prop(i,         j+iv[1]-1, k        )
                             + macro_prop(i,         j,         k+iv[2]-1)
                             + macro_prop(i+iv[0]-1, j+iv[1]-1, k        )
                             + macro_prop(i+iv[0]-1, j        , k+iv[2]-1)
                             + macro_prop(i,         j+iv[1]-1, k+iv[2]-1)
                             + macro_prop(i+iv[0]-1, j+iv[1]-1, k+iv[2]-1) ) );
     }

     AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
     static amrex::Real alpha (amrex::Array4<amrex::Real> const& sigma,
                               amrex::Array4<amrex::Real> const& epsilon,
                               amrex::Real dt, int i, int j, int k,
                               amrex::IntVect iv_cc) {
         using namespace amrex;
         amrex::Real fac1 = macro_avg_to_edge(i, j, k, iv_cc, sigma) * dt
                            / macro_avg_to_edge(i, j, k, iv_cc, epsilon);
         amrex::Real alpha = 1._rt/ (1._rt + fac1);
         return alpha;
     };

     AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
     static amrex::Real beta (amrex::Array4<amrex::Real> const& sigma,
                              amrex::Array4<amrex::Real> const& epsilon,
                              amrex::Real dt, int i, int j, int k,
                              amrex::IntVect iv_cc) {
         using namespace amrex;
         amrex::Real fac1 = macro_avg_to_edge(i, j, k, iv_cc, sigma) * dt
                            / macro_avg_to_edge(i, j, k, iv_cc, epsilon);
         amrex::Real beta = dt / ( macro_avg_to_edge(i, j, k, iv_cc, epsilon) * (1._rt + fac1) );
         return beta;
     };
};

#endif // WARPX_MACROSCOPIC_PROPERTIES_H_
